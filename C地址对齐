struct A{    /* 偏移量  需补字节    占字节数   */
    char c1;  //  0        0           1
	short s1;   //  1        1           2           
	char c2;    //  4        0           1
	float f1;   //  5        3           4
	double d1;  //  12       4           8
	            /*合计 20字节 不是边界(double类型8字节)的倍数  补上4字节 共24*/
};
 
struct B{     /* 偏移量  需补字节    占字节数   */
    char c1;  //   0        0           1
	char c2;    //   1        0           1
	short s1;   //   2        0           2
	float f1;   //   4        0           4
	double d1;  //   8        0           8
	            /*合计 16字节 是边界(double类型8字节)的倍数  补上0字节 共16*/
};
    为了提高CPU的存储速度，编译器对一些变量的起始地址做了“对齐”处理。在默认情况下，规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。
    
    下面列出常用类型的对齐方式：
    Char    偏移量必须为sizeof(char)即1的倍数
    int     偏移量必须为sizeof(int)即4的倍数
    float   偏移量必须为sizeof(float)即4的倍数
    double  偏移量必须为sizeof(double)即8的倍数
    Short   偏移量必须为sizeof(short)即2的倍数

    各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节编译器会自动填充。同时编译器为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。

    gcc对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也可以屏蔽掉变量默认的对齐方式，自己设定变量的对齐方式。gcc中提供了#pragma pack(n)来设定变量以n字节对齐方式。
    n字节对齐就是说变量存放的起始地址的偏移量有两种情况：
    第一、如果该变量所占用的字节数小于等于n，那么偏移量必须满足默认的对齐方式；
    第二、如果该变量的类型所占用的字节数大于n，那么偏移量为n的倍数，不用满足默认的对齐方式。
    结构的总大小也有个约束条件，分下面两种情况：
    如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。

例1：
#pragma pack(push) //保存对齐状态
#pragma pack(4)//设定为4字节对齐
struct test
{
  char m1;//小于4，采用默认，1个字节
  double m4;//大于4，则偏移量必须是n的倍数，补3个字节，在放m4
  int  m3;//等于4，采用默认，4个字节
  //总大小应为n的倍数，是16个字节
};
#pragma pack(pop)//恢复对齐状态

例2：
#pragma pack(8)//设定为8字节对齐
struct s1{
short a;//小于8，采用默认，2个字节
long b;//小于8，采用默认补2个字节，再放b
};//一共8个字节
struct s2{
char c;//小于8，采用默认，1个字节
s1 d;//等于8，采用默认，补7个字节，再放s1
long long e;//小于8，采用默认，4个字节
};//一共20个字节，不是n的倍数，所以应补4个字节，最后为24个字节
#pragma pack()
